import 'package:flutter/foundation.dart';
import 'package:html/dom.dart';
import 'package:html/parser.dart';

import 'schemaorg.dart';
import 'opengraph.dart';
import 'utils.dart';
import 'grouping_utils.dart';

/// Base scraper implementation with fallback mechanisms
class AbstractScraper {
  late String pageData;
  late String url;
  late Document soup;
  late SchemaOrg schema;
  late OpenGraph opengraph;

  static const version = "15.7.1";
  // Some sites close their content for 'bots', so user-agent must be supplied
  static final Map<String, String> headers = {
    "User-Agent":
        "Mozilla/5.0 (compatible; Windows NT 10.0; Win64; x64; rv:$version) recipe-scrapers/$version",
  };

  AbstractScraper(String pageData, String url) {
    this.pageData = pageData;
    this.url = url;
    soup = parse(this.pageData);
    opengraph = OpenGraph(soup);
    schema = SchemaOrg(this.pageData);
  }

  String canonicalUrl() {
    Element? canonicalLink = soup.querySelector("link[rel='canonical'][href]");
    if (canonicalLink != null && canonicalLink.attributes.containsKey('href')) {
      return joinUrl(url, canonicalLink.attributes['href']!);
    }
    return url;
  }

  /// Get the host domain
  String host() {
    try {
      final uri = Uri.parse(url);
      return uri.host.toLowerCase();
    } catch (e) {
      return "";
    }
  }

  String language() {
    Map<String, bool> candidateLanguages = <String, bool>{};
    Element? html = soup.querySelector("html[lang]");
    if (html != null && html.attributes.containsKey('lang')) {
      candidateLanguages[html.attributes['lang']!] = true;
    }

    // Deprecated: check for a meta http-equiv header
    // See: https://www.w3.org/International/questions/qa-http-and-lang
    Element? metaLanguage = soup.querySelector("meta[http-equiv][content]");
    if (metaLanguage != null &&
        metaLanguage.attributes.containsKey('http-equiv') &&
        metaLanguage.attributes['http-equiv']!.toLowerCase() == 'content-language' &&
        metaLanguage.attributes.containsKey('content')) {
      String language = metaLanguage.attributes['content']!.split(',')[0];
      if (language.isNotEmpty) {
        candidateLanguages[language] = true;
      }
    }

    // If other languages exist, remove 'en' commonly generated by HTML editors
    if (candidateLanguages.length > 1) {
      candidateLanguages.remove('en');
    }

    // Return the first candidate language
    if (candidateLanguages.isNotEmpty) {
      return candidateLanguages.keys.first;
    } else {
      throw ElementNotFoundInHtml("Could not find language.");
    }
  }

  /// Get site name with fallback to OpenGraph
  String siteName() {
    try {
      // Try schema first
      var schemaSiteName = schema.siteName;
      if (schemaSiteName != null && schemaSiteName.isNotEmpty) {
        return schemaSiteName;
      }

      // Try OpenGraph next
      var ogSiteName = opengraph.siteName;
      if (ogSiteName != null && ogSiteName.isNotEmpty) {
        return ogSiteName;
      }
    } catch (e) {
      debugPrint("Error extracting site name: $e");
    }

    return host();
  }

  /// Get title with fallback to OpenGraph
  String title() {
    try {
      // Try schema first
      var schemaTitle = schema.name;
      if (schemaTitle != null && schemaTitle.isNotEmpty) {
        return schemaTitle;
      }

      // Try OpenGraph next
      var ogTitle = opengraph.title;
      if (ogTitle != null && ogTitle.isNotEmpty) {
        return ogTitle;
      }
    } catch (e) {
      debugPrint("Error extracting title: $e");
    }

    throw ElementNotFoundInHtml("Could not find recipe title");
  }

  /// Get ingredients with fallback to HTML parsing
  List<String> ingredients() {
    try {
      // Try schema first
      var schemaIngredients = schema.recipeIngredients;
      if (schemaIngredients != null && schemaIngredients.isNotEmpty) {
        return schemaIngredients;
      }
    } catch (e) {
      debugPrint("Error extracting ingredients: $e");
    }

    throw ElementNotFoundInHtml("Could not find ingredients");
  }

  /// Get instructions with fallback to HTML parsing
  String instructions() {
    // try {
    //   // Try schema first
    //   var schemaInstructions = schema.recipeInstructions;
    //   if (schemaInstructions != null && schemaInstructions.isNotEmpty) {
    //     return decodeHtmlEntities(schemaInstructions);
    //   }
    // } catch (e) {
    //   debugPrint("Error extracting instructions: $e");
    // }

    throw ElementNotFoundInHtml("Could not find instructions");
  }

  List<String> instructionsList() {
    var schemaInstructions = schema.recipeInstructions;
    if (schemaInstructions != null && schemaInstructions.isNotEmpty) {
      return decodeHtmlEntities(
        schemaInstructions,
      ).split('\n').where((instruction) => instruction.isNotEmpty).toList();
    }
    return [];
  }

  String category() {
    var schemaCategory = schema.category;
    if (schemaCategory != null && schemaCategory.isNotEmpty) {
      return decodeHtmlEntities(schemaCategory);
    }
    return "";
  }

  String makeAhead() {
    // TODO: Implement makeAhead logic
    return "";
  }

  String datePublished() {
    return schema.datePublished ?? "";
  }

  /// Get image URL with fallback to OpenGraph
  String image() {
    try {
      // Try schema first
      var schemaImage = schema.image;
      if (schemaImage != null && schemaImage.isNotEmpty) {
        return schemaImage;
      }

      // Try OpenGraph next
      var ogImage = opengraph.image;
      if (ogImage != null && ogImage.isNotEmpty) {
        return ogImage;
      }
    } catch (e) {
      debugPrint("Error extracting image: $e");
    }

    throw ElementNotFoundInHtml("Could not find image");
  }

  /// Get yields/servings with fallback to parsing
  String yields() {
    try {
      // Try schema first
      var schemaYield = schema.recipeYield;
      if (schemaYield != null && schemaYield.isNotEmpty) {
        return getYields(schemaYield);
      }
    } catch (e) {
      debugPrint("Error extracting yields: $e");
    }

    return "4"; // default yield if not found

    //throw ElementNotFoundInHtml("Could not find yields");
  }

  /// Get author with fallback to OpenGraph
  String author() {
    try {
      // Try schema first
      var schemaAuthor = schema.author;
      if (schemaAuthor != null && schemaAuthor.isNotEmpty) {
        return schemaAuthor;
      }

      // Try meta tag
      Element? metaAuthor = soup.querySelector('meta[name="author"]');
      if (metaAuthor != null && metaAuthor.attributes.containsKey('content')) {
        return metaAuthor.attributes['content']!;
      }
    } catch (e) {
      debugPrint("Error extracting author: $e");
    }

    throw ElementNotFoundInHtml("Could not find author");
  }

  /// Get prep time with fallback to HTML parsing
  int? prepTime() {
    try {
      // Try schema first
      return schema.prepTime;
    } catch (e) {
      debugPrint("Error extracting prep time: $e");
    }

    return null;
  }

  /// Get cook time with fallback to HTML parsing
  int? cookTime() {
    try {
      // Try schema first
      return schema.cookTime;
    } catch (e) {
      debugPrint("Error extracting cook time: $e");
    }

    return null;
  }

  /// Get total time (cook + prep)
  int? totalTime() {
    try {
      // Try schema first
      return schema.totalTime;
    } catch (e) {
      debugPrint("Error extracting cook time: $e");
    }

    return null;
  }

  String cuisine() {
    return schema.cuisine ?? "";
  }

  String countryCode() {
    // Helper function to map cuisine names to country codes

    // Convert to lowercase for case-insensitive matching
    final lowerCuisine = schema.cuisine?.toLowerCase().trim();

    // Map of common cuisines to ISO country codes
    final Map<String, String> cuisineMap = {
      'american': 'US',
      'british': 'GB',
      'chinese': 'CN',
      'french': 'FR',
      'german': 'DE',
      'greek': 'GR',
      'indian': 'IN',
      'italian': 'IT',
      'japanese': 'JP',
      'mexican': 'MX',
      'spain': 'ES',
      'thai': 'TH',
      // Add more as needed
    };

    return cuisineMap[lowerCuisine] ?? 'WW';
  }

  String cookingMethod() {
    throw UnimplementedError("This should be implemented.");
  }

  double ratings() {
    return schema.ratings ?? 0.0;
  }

  int ratingsCount() {
    return safeToIntWithDefault(schema.ratingsCount, 0);
  }

  List<String> equipment() {
    throw UnimplementedError("This should be implemented.");
  }

  List<IngredientGroup> ingredientGroups() {
    throw UnimplementedError("This should be implemented.");
  }

  List<dynamic> reviews() {
    throw UnimplementedError("This should be implemented.");
  }

  /// Get recipe description with fallback to OpenGraph
  String? description() {
    try {
      // Try schema first
      var schemaDescription = schema.description;
      if (schemaDescription != null && schemaDescription.isNotEmpty) {
        return decodeHtmlEntities(schemaDescription);
      }

      // Try OpenGraph next
      var ogDescription = opengraph.description;
      if (ogDescription != null && ogDescription.isNotEmpty) {
        return decodeHtmlEntities(ogDescription);
      }
    } catch (e) {
      debugPrint("Error extracting description: $e");
    }

    return null;
  }

  /// Get nutritional information
  Map<String, dynamic> nutrients() {
    try {
      // Try schema
      final nutrition = schema.nutrition;
      if (nutrition != null) {
        final Map<String, dynamic> numericValues = {};
        nutrition.forEach((key, value) {
          numericValues[key] = value;
        });
        return numericValues;
      }
    } catch (e) {
      debugPrint("Error extracting nutrients: $e");
    }

    return {};
  }

  Map<String, dynamic> numericNutrients() {
    try {
      // Try schema
      final nutrition = schema.nutrition;
      if (nutrition != null) {
        final Map<String, dynamic> numericValues = {};
        nutrition.forEach((key, value) {
          try {
            // Try to extract numeric values
            final match = RegExp(r'(\d+(\.\d+)?)').firstMatch(value);
            if (match != null) {
              numericValues[key] = double.parse(match.group(1)!);
            } else {
              numericValues[key] = value;
            }
          } catch (e) {
            numericValues[key] = value;
          }
        });
        return numericValues;
      }
    } catch (e) {
      debugPrint("Error extracting nutrients: $e");
    }

    return {};
  }

  List<String> dietaryRestrictions() {
    throw UnimplementedError("This should be implemented.");
  }

  /// Keywords or tags used to describe the recipe
  List<String> keywords() {
    return schema.keywords ?? [];
  }

  List<String> stepImages() {
    return []; // Default empty list, should be overridden by specific scrapers
  }

  /// Links found in the recipe.
  List<Map<String, String>> links() {
    Set<String> invalidHref = {"#", ""};
    List<Element> linksHtml = soup.querySelectorAll("a[href]");
    return [];
    // TODO fix
    // return linksHtml
    //     .where(
    //       (link) =>
    //           link.attributes.containsKey('href') && !invalidHref.contains(link.attributes['href']),
    //     )
    //     .map((link) => {'href': link.attributes['href'] ?? '', 'text': link.text})
    //     .toList();
  }

  Map<String, dynamic> toJson() {
    Map<String, dynamic> jsonDict = {};

    try {
      jsonDict['author'] = author();
    } catch (e) {}
    try {
      jsonDict['canonical_url'] = canonicalUrl();
    } catch (e) {}
    try {
      jsonDict['site_name'] = siteName();
    } catch (e) {}
    try {
      jsonDict['host'] = host();
    } catch (e) {}
    try {
      jsonDict['language'] = language();
    } catch (e) {}
    try {
      jsonDict['title'] = title();
    } catch (e) {}
    try {
      jsonDict['ingredients'] = ingredients();
    } catch (e) {}
    try {
      jsonDict['ingredient_groups'] = ingredientGroups().map((group) => group.toJson()).toList();
    } catch (e) {}
    try {
      jsonDict['instructions'] = instructions();
    } catch (e) {}
    try {
      jsonDict['instructions_list'] = instructionsList();
    } catch (e) {}
    try {
      jsonDict['category'] = category();
    } catch (e) {}
    try {
      jsonDict['yields'] = yields();
    } catch (e) {}
    try {
      final desc = description();
      if (desc != null && desc.isNotEmpty) {
        jsonDict['description'] = desc;
      }
    } catch (e) {}
    try {
      jsonDict['total_time'] = totalTime();
    } catch (e) {}
    try {
      jsonDict['cook_time'] = cookTime();
    } catch (e) {}
    try {
      jsonDict['prep_time'] = prepTime();
    } catch (e) {}
    try {
      jsonDict['cuisine'] = cuisine();
    } catch (e) {}
    try {
      jsonDict['cooking_method'] = cookingMethod();
    } catch (e) {}
    try {
      jsonDict['ratings'] = ratings();
    } catch (e) {}
    try {
      jsonDict['ratings_count'] = ratingsCount();
    } catch (e) {}
    try {
      jsonDict['equipment'] = equipment();
    } catch (e) {}
    try {
      jsonDict['reviews'] = reviews();
    } catch (e) {}
    try {
      final nutrientData = nutrients();
      if (nutrientData.isNotEmpty) {
        jsonDict['nutrients'] = nutrientData;
      }
    } catch (e) {}
    try {
      jsonDict['dietary_restrictions'] = dietaryRestrictions();
    } catch (e) {}
    try {
      jsonDict['image'] = image();
    } catch (e) {}
    try {
      jsonDict['keywords'] = keywords();
    } catch (e) {}
    try {
      final linksList = links();
      if (linksList.isNotEmpty) {
        jsonDict['links'] = linksList;
      }
    } catch (e) {}

    return jsonDict;
  }

  String joinUrl(String baseUrl, String path) {
    if (path.startsWith('http://') || path.startsWith('https://')) {
      return path;
    }
    Uri baseUri = Uri.parse(baseUrl);
    return Uri(
      scheme: baseUri.scheme,
      host: baseUri.host,
      path: path.startsWith('/') ? path : '/${path}',
    ).toString();
  }

  /// Helper method to safely convert numeric values to integers
  int? safeToInt(dynamic value) {
    if (value == null) return null;
    if (value is int) return value;
    if (value is double) return value.round();
    if (value is String) {
      try {
        return double.parse(value).round();
      } catch (e) {
        return null;
      }
    }
    return null;
  }

  /// Helper method to convert numeric values to integers with a default
  int safeToIntWithDefault(dynamic value, int defaultValue) {
    return safeToInt(value) ?? defaultValue;
  }

  /// Helper method to safely convert values to doubles
  double? safeToDouble(dynamic value) {
    if (value == null) return null;
    if (value is double) return value;
    if (value is int) return value.toDouble();
    if (value is String) {
      try {
        return double.parse(value);
      } catch (e) {
        return null;
      }
    }
    return null;
  }
}
