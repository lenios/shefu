import 'package:flutter/foundation.dart';
import 'package:html/dom.dart';
import 'package:html/parser.dart';

import 'schemaorg.dart';
import 'opengraph.dart';
import 'utils.dart';
import 'grouping_utils.dart';

/// Base scraper implementation with fallback mechanisms
class AbstractScraper {
  late String pageData;
  late String url;
  late Document soup;
  late SchemaOrg schema;
  late OpenGraph opengraph;

  // Field to store override values
  final Map<String, dynamic> _overrides = {};

  // Add setter/getter methods
  void setOverride(String key, dynamic value) {
    _overrides[key] = value;
  }

  T? getOverride<T>(String key) {
    if (_overrides.containsKey(key) && _overrides[key] is T) {
      return _overrides[key] as T;
    }
    return null;
  }

  static const version = "15.7.1";
  // Some sites close their content for 'bots', so user-agent must be supplied
  static final Map<String, String> headers = {
    "User-Agent":
        "Mozilla/5.0 (compatible; Windows NT 10.0; Win64; x64; rv:$version) recipe-scrapers/$version",
  };

  AbstractScraper(this.pageData, this.url) {
    soup = parse(pageData);
    opengraph = OpenGraph(soup);
    schema = SchemaOrg(pageData);
  }

  String canonicalUrl() {
    Element? canonicalLink = soup.querySelector("link[rel='canonical']");
    if (canonicalLink != null && canonicalLink.attributes.containsKey('href')) {
      return joinUrl(url, canonicalLink.attributes['href']!);
    }

    Element? ogUrlElement = soup.querySelector('meta[property="og:url"], meta[name="og:url"]');
    if (ogUrlElement != null && ogUrlElement.attributes.containsKey('content')) {
      return ogUrlElement.attributes['content']!;
    }

    return url;
  }

  /// Get the host domain
  String host() {
    try {
      final uri = Uri.parse(url);
      return uri.host.toLowerCase();
    } catch (e) {
      return "";
    }
  }

  String? language() {
    Map<String, bool> candidateLanguages = <String, bool>{};
    Element? html = soup.querySelector("html[lang]");
    if (html != null && html.attributes.containsKey('lang')) {
      candidateLanguages[html.attributes['lang']!] = true;
    }

    // Deprecated: check for a meta http-equiv header
    // See: https://www.w3.org/International/questions/qa-http-and-lang
    Element? metaLanguage = soup.querySelector("meta[http-equiv][content]");
    if (metaLanguage != null &&
        metaLanguage.attributes.containsKey('http-equiv') &&
        metaLanguage.attributes['http-equiv']!.toLowerCase() == 'content-language' &&
        metaLanguage.attributes.containsKey('content')) {
      String language = metaLanguage.attributes['content']!.split(',')[0];
      if (language.isNotEmpty) {
        candidateLanguages[language] = true;
      }
    }

    // If other languages exist, remove 'en' commonly generated by HTML editors
    if (candidateLanguages.length > 1) {
      candidateLanguages.remove('en');
    }

    // Return the first candidate language
    if (candidateLanguages.isNotEmpty) {
      return candidateLanguages.keys.first;
    } else {
      return null;
    }
  }

  /// Get site name with fallback to OpenGraph
  String siteName() {
    try {
      // Try schema first
      var schemaSiteName = schema.siteName;
      if (schemaSiteName != null && schemaSiteName.isNotEmpty) {
        return decodeHtmlEntities(schemaSiteName);
      }

      // Try OpenGraph next
      var ogSiteName = opengraph.siteName;
      if (ogSiteName != null && ogSiteName.isNotEmpty) {
        return decodeHtmlEntities(ogSiteName);
      }
    } catch (e) {
      debugPrint("Error extracting site name: $e");
    }

    return host();
  }

  /// Get title with fallback to OpenGraph
  String title() {
    try {
      // Try schema
      var schemaTitle = schema.name;
      if (schemaTitle != null && schemaTitle.isNotEmpty) {
        return schemaTitle;
      }

      // Try OpenGraph next
      var ogTitle = opengraph.title;
      if (ogTitle != null && ogTitle.isNotEmpty) {
        return ogTitle;
      }

      // Try element with itemprop="name" first
      Element? nameElement = soup.querySelector('[itemprop="name"]');
      if (nameElement != null && nameElement.text.isNotEmpty) {
        return nameElement.text.trim();
      }
    } catch (e) {
      debugPrint("Error extracting title: $e");
    }

    throw ElementNotFoundInHtml("Could not find recipe title");
  }

  /// Get ingredients with fallback to HTML parsing
  List<String> ingredients() {
    final override = getOverride<List<String>>('ingredients');
    if (override != null) {
      return override;
    }

    try {
      // Try schema first
      var schemaIngredients = schema.recipeIngredients;
      if (schemaIngredients != null && schemaIngredients.isNotEmpty) {
        return schemaIngredients
            .map((ingredient) => ingredient.replaceAll('((', '(').replaceAll('))', ')'))
            .where(
              (ingredient) =>
                  !(ingredient.toLowerCase().startsWith('for ') && ingredient.endsWith(':')),
            )
            .toList();
      }
    } catch (e) {
      debugPrint("Error extracting ingredients: $e");
    }

    // Try HTML element with itemprop="recipeIngredient"
    final ingredientElements = soup.querySelectorAll('span[itemprop="recipeIngredient"]');
    if (ingredientElements.isNotEmpty) {
      return ingredientElements
          .map((element) => element.text.trim().replaceAll(RegExp(r'\s+'), ' '))
          .where((text) => text.isNotEmpty)
          .where(
            (ingredient) =>
                !(ingredient.toLowerCase().startsWith('for ') && ingredient.endsWith(':')),
          )
          .toList();
    }

    throw ElementNotFoundInHtml("Could not find ingredients");
  }

  List<String> instructionsList() {
    final override = getOverride<List<String>>('instructions_list');
    if (override != null) {
      return override;
    }

    var schemaInstructions = schema.recipeInstructions;
    if (schemaInstructions != null && schemaInstructions.isNotEmpty) {
      return decodeHtmlEntities(schemaInstructions)
          .split('\n')
          .map((instruction) => instruction.trim())
          .where((instruction) => instruction.isNotEmpty)
          .toList();
    }

    // Try to find element with itemprop="recipeInstructions"
    List<Element>? instructionsElements = soup.querySelectorAll('[itemprop="recipeInstructions"]');
    if (instructionsElements.isNotEmpty) {
      List<String> result = [];
      for (var element in instructionsElements) {
        result.addAll(phrases(element.text.trim()).where((text) => text.isNotEmpty));
      }
      return result;
    }

    return [];
  }

  String category() {
    final override = getOverride<String>('category');
    if (override != null) {
      return override;
    }

    var schemaCategory = schema.category;
    if (schemaCategory != null && schemaCategory.isNotEmpty) {
      return decodeHtmlEntities(schemaCategory);
    }
    return "";
  }

  String? makeAhead() {
    final override = getOverride<String>('makeAhead');
    if (override != null) {
      return override;
    }

    // Try to extract from schema HowtoTip
    final howtoTip = schema.howtoTip;
    if (howtoTip != null && howtoTip.startsWith("Storage: ")) {
      return howtoTip.substring(9).trim();
    }
    return null;
  }

  String datePublished() {
    return schema.datePublished ?? "";
  }

  /// Get image URL with fallback to OpenGraph
  String image() {
    try {
      // Try schema first
      var schemaImage = schema.image;
      if (schemaImage != null && schemaImage.isNotEmpty) {
        return schemaImage;
      }

      // Try OpenGraph next
      var ogImage = opengraph.image;
      if (ogImage != null && ogImage.isNotEmpty) {
        return ogImage;
      }
    } catch (e) {
      debugPrint("Error extracting image: $e");
    }

    throw ElementNotFoundInHtml("Could not find image");
  }

  String? video() {
    var schemaVideo = schema.video;
    if (schemaVideo != null && schemaVideo.isNotEmpty) {
      return schemaVideo;
    }

    return null; // No video found
  }

  /// Get yields/servings with fallback to parsing
  String yields() {
    final override = getOverride<String>('yields');
    if (override != null) {
      return override;
    }

    try {
      // Try schema first
      var schemaYield = schema.recipeYield;
      if (schemaYield != null && schemaYield.isNotEmpty) {
        return getYields(schemaYield);
      }

      // Try element with itemprop="recipeYield"
      Element? yieldElement = soup.querySelector('[itemprop="recipeYield"]');
      if (yieldElement != null) {
        if (yieldElement.attributes.containsKey('content')) {
          return getYields(yieldElement.attributes['content']!.trim());
        }
      }

      var soupYield = soup.querySelector("option.yield")?.text;
      if (soupYield != null && soupYield.isNotEmpty) {
        return getYields(soupYield);
      }
    } catch (e) {
      debugPrint("Error extracting yields: $e");
    }

    return "4"; // default yield if not found

    //throw ElementNotFoundInHtml("Could not find yields");
  }

  /// Get author with fallback to OpenGraph
  String author() {
    final override = getOverride<String>('author');
    if (override != null) {
      return override;
    }

    try {
      // try copyright notice first
      String? copyrightNotice = schema.copyrightNotice;
      if (copyrightNotice != null && copyrightNotice.isNotEmpty) {
        return copyrightNotice;
      }

      // Try schema
      var schemaAuthor = schema.author;
      if (schemaAuthor != null && schemaAuthor.isNotEmpty) {
        return schemaAuthor;
      }

      // Try meta tag
      Element? metaAuthor = soup.querySelector('meta[name="author"]');
      if (metaAuthor != null && metaAuthor.attributes.containsKey('content')) {
        return metaAuthor.attributes['content']!;
      }
    } catch (e) {
      debugPrint("Error extracting author: $e");
    }

    // Try element with itemprop="author"
    Element? authorElement = soup.querySelector('[itemprop="author"]');
    if (authorElement != null && authorElement.text.isNotEmpty) {
      return authorElement.text.trim();
    }

    throw ElementNotFoundInHtml("Could not find author");
  }

  /// Get prep time with fallback to HTML parsing
  int? prepTime() {
    final override = getOverride<int>('prep_time');
    if (override != null) {
      return override;
    }

    try {
      // Try schema first
      return schema.prepTime;
    } catch (e) {
      debugPrint("Error extracting prep time: $e");
    }

    return null;
  }

  /// Get cook time with fallback to HTML parsing
  int? cookTime() {
    final override = getOverride<int>('cook_time');
    if (override != null) {
      return override;
    }

    final time = schema.cookTime;
    return time != null && time > 0 ? time : null;
  }

  /// Get total time (cook + prep)
  int? totalTime() {
    final override = getOverride<int>('total_time');
    if (override != null) {
      return override;
    }

    try {
      // Try schema first
      var schemaTotalTime = schema.totalTime;
      if (schemaTotalTime != null && schemaTotalTime > 0) {
        return schemaTotalTime;
      }

      Element? totalTimeElement = soup.querySelector('[itemprop="totalTime"]');
      if (totalTimeElement != null) {
        if (totalTimeElement.attributes.containsKey('content')) {
          return parseISODuration(totalTimeElement.attributes['content']!.trim());
        }
      }
    } catch (e) {
      debugPrint("Error extracting cook time: $e");
    }

    return null;
  }

  String cuisine() {
    return schema.cuisine ?? "";
  }

  String countryCode() {
    // Helper function to map cuisine names to country codes

    // Convert to lowercase for case-insensitive matching
    final lowerCuisine = schema.cuisine?.toLowerCase().trim();

    // Map of common cuisines to ISO country codes
    final Map<String, String> cuisineMap = {
      'american': 'US',
      'british': 'GB',
      'chinese': 'CN',
      'french': 'FR',
      'german': 'DE',
      'greek': 'GR',
      'indian': 'IN',
      'italian': 'IT',
      'japanese': 'JP',
      'mexican': 'MX',
      'spain': 'ES',
      'thai': 'TH',
      // Add more as needed
    };

    return cuisineMap[lowerCuisine] ?? 'WW';
  }

  String? cookingMethod() {
    return schema.cookingMethod;
  }

  double ratings() {
    return schema.ratings ?? 0.0;
  }

  int ratingsCount() {
    return safeToIntWithDefault(schema.ratingsCount, 0);
  }

  List<String> equipment() {
    final override = getOverride<List<String>>('equipment');
    if (override != null) {
      return override;
    }

    final equipmentItems = soup.querySelectorAll('.wprm-recipe-equipment-name');
    return equipmentItems.map((item) => item.text.trim()).toList();
  }

  List<IngredientGroup>? ingredientGroups() {
    final override = getOverride<List<IngredientGroup>>('ingredient_groups');
    if (override != null) {
      return override;
    }

    // first try to find groups in HTML
    final groups = soup.querySelectorAll('.Recipe__ingredientsGroup');
    if (groups.isNotEmpty) {
      final ingredientGroups = <IngredientGroup>[];
      for (final group in groups) {
        final purposeElement = group.querySelector('.Recipe__ingredientsGroupName');
        final heading = purposeElement?.text.trim();
        final ingredients = group
            .querySelectorAll('.Recipe__ingredient')
            .map((e) => normalizeString(e.text))
            .toList();
        ingredientGroups.add(IngredientGroup(ingredients: ingredients, heading: heading));
      }
      if (ingredientGroups.any((g) => g.ingredients.isNotEmpty)) {
        return ingredientGroups;
      }
    }

    try {
      // Try to get ingredients from schema data
      final ingredientsList = ingredients();
      if (ingredientsList.isNotEmpty) {
        return groupIngredients(ingredientsList, soup);
      }
      return [];

      // Attempt to group the ingredients using the groupIngredients utility
    } catch (e) {
      debugPrint("Error extracting ingredient groups: $e");

      // If all else fails, return a single group with all ingredients
      // try {
      //   final allIngredients = ingredients();
      //   if (allIngredients.isNotEmpty) {
      //     return [IngredientGroup(ingredients: allIngredients)];
      //   }
      // } catch (ex) {
      //   debugPrint("Error falling back to simple ingredient list: $ex");
      // }
    }

    // Return empty list if nothing found
    return [];
  }

  List<dynamic> reviews() {
    return [];
    //throw UnimplementedError("This should be implemented.");
  }

  /// Get recipe description with fallback to OpenGraph
  String? description() {
    final override = getOverride<String>('description');
    if (override != null) {
      return override;
    }

    try {
      // Try schema first
      final schemaDescription = schema.description;
      if (schemaDescription?.isNotEmpty ?? false) {
        return decodeHtmlEntities(schemaDescription!);
      }

      // Try OpenGraph next
      final ogDescription = opengraph.description;
      if (ogDescription?.isNotEmpty ?? false) {
        return decodeHtmlEntities(ogDescription!).replaceAll(RegExp(r'\s+'), ' ').trim();
      }
    } catch (e) {
      debugPrint("Error extracting description: $e");
    }

    return null;
  }

  /// Get nutritional information
  Map<String, dynamic> nutrients() {
    final override = getOverride<Map<String, dynamic>>('nutrients');
    if (override != null) {
      return override;
    }

    try {
      // Try schema
      final nutrition = schema.nutrition;
      if (nutrition != null) {
        final Map<String, dynamic> numericValues = {};
        nutrition.forEach((key, value) {
          numericValues[key] = value;
        });
        return numericValues;
      }
    } catch (e) {
      debugPrint("Error extracting nutrients: $e");
    }

    return {};
  }

  Map<String, dynamic> numericNutrients() {
    try {
      // Try schema
      final nutrition = schema.nutrition;
      if (nutrition != null) {
        final Map<String, dynamic> numericValues = {};
        nutrition.forEach((key, value) {
          try {
            // Try to extract numeric values
            final match = RegExp(r'(\d+(\.\d+)?)').firstMatch(value);
            if (match != null) {
              numericValues[key] = double.parse(match.group(1)!);
            } else {
              numericValues[key] = value;
            }
          } catch (e) {
            numericValues[key] = value;
          }
        });
        return numericValues;
      }
    } catch (e) {
      debugPrint("Error extracting nutrients: $e");
    }

    return {};
  }

  List<String>? dietaryRestrictions() {
    return schema.dietaryRestrictions;
  }

  /// Keywords or tags used to describe the recipe
  List<String> keywords() {
    return schema.keywords ?? [];
  }

  List<Map<String, String>> questions() {
    return schema.questions();
  }

  List<String> stepImages() {
    final schema = this.schema;
    List<String> imageUrls = [];

    // for each step, add the image URL (or empty string if not found) to imageUrls
    var recipeData = schema.getRecipeData();
    if (recipeData != null && recipeData.containsKey('recipeInstructions')) {
      final instructions = recipeData['recipeInstructions'];

      if (instructions is List) {
        for (final instruction in instructions) {
          String stepImageUrl = '';
          if (instruction is Map<String, dynamic> && instruction.containsKey('image')) {
            final image = instruction['image'];
            if (image is String) {
              stepImageUrl = image;
            } else if (image is List && image.isNotEmpty) {
              final firstImg = image.first;
              if (firstImg is String) {
                stepImageUrl = firstImg;
              } else if (firstImg is Map && firstImg.containsKey('url')) {
                stepImageUrl = firstImg['url'] as String? ?? '';
              }
            } else if (image is Map && image.containsKey('url')) {
              stepImageUrl = image['url'] as String? ?? '';
            }
          }
          imageUrls.add(stepImageUrl);
        }
        // If all instructions returned '', return empty list
        if (imageUrls.every((url) => url.isEmpty)) {
          imageUrls.clear();
        }
      }
    }

    return imageUrls;
  }

  /// Links found in the recipe.
  List<Map<String, String>> links() {
    //Set<String> invalidHref = {"#", ""};
    //List<Element> linksHtml = soup.querySelectorAll("a[href]");
    // TODO fix
    // return linksHtml
    //     .where(
    //       (link) =>
    //           link.attributes.containsKey('href') && !invalidHref.contains(link.attributes['href']),
    //     )
    //     .map((link) => {'href': link.attributes['href'] ?? '', 'text': link.text})
    //     .toList();
    return [];
  }

  Map<String, dynamic> toJson() {
    Map<String, dynamic> jsonDict = {};

    try {
      jsonDict['author'] = author();
      jsonDict['canonical_url'] = canonicalUrl();
      jsonDict['site_name'] = siteName();
      jsonDict['host'] = host();

      if (language() != null) jsonDict['language'] = language();

      jsonDict['title'] = decodeHtmlEntities(title());
      jsonDict['ingredients'] = ingredients();
      if (ingredientGroups() != null && ingredientGroups()!.isNotEmpty) {
        jsonDict['ingredient_groups'] = ingredientGroups()!.map((group) => group.toJson()).toList();
      }
      jsonDict['instructions_list'] = instructionsList();

      if (stepImages().isNotEmpty) jsonDict['step_images'] = stepImages();
      if (category().isNotEmpty) jsonDict['category'] = decodeHtmlEntities(category());
      jsonDict['yields'] = yields();
      jsonDict['description'] = description();
      jsonDict['total_time'] = totalTime();
      if (cookTime() != null) jsonDict['cook_time'] = cookTime();
      if (prepTime() != null) jsonDict['prep_time'] = prepTime();
      if (cuisine().isNotEmpty) jsonDict['cuisine'] = decodeHtmlEntities(cuisine());

      if (cookingMethod() != null && cookingMethod()!.isNotEmpty) {
        jsonDict['cooking_method'] = cookingMethod();
      }
      if (ratings() > 0) jsonDict['ratings'] = ratings();
      if (ratingsCount() > 0) jsonDict['ratings_count'] = ratingsCount();
      if (equipment().isNotEmpty) jsonDict['equipment'] = equipment();

      //jsonDict['reviews'] = reviews();
      final nutrientData = nutrients();
      if (nutrientData.isNotEmpty) {
        jsonDict['nutrients'] = nutrientData;
      }
      if (dietaryRestrictions() != null) {
        jsonDict['dietary_restrictions'] = dietaryRestrictions();
      }
      jsonDict['image'] = image();
      if (video() != null && video()!.isNotEmpty) jsonDict['video'] = video();
      if (keywords().isNotEmpty) jsonDict['keywords'] = keywords();
      if (questions().isNotEmpty) jsonDict['questions'] = questions();
      if (makeAhead() != null && makeAhead()!.isNotEmpty) jsonDict['makeAhead'] = makeAhead();

      final linksList = links();
      if (linksList.isNotEmpty) {
        jsonDict['links'] = linksList;
      }
    } catch (e) {
      debugPrint("Error extracting JSON: $e");
    }
    return jsonDict;
  }

  String joinUrl(String baseUrl, String path) {
    if (path.startsWith('http://') || path.startsWith('https://')) {
      return path;
    }
    Uri baseUri = Uri.parse(baseUrl);
    return Uri(
      scheme: baseUri.scheme,
      host: baseUri.host,
      path: path.startsWith('/') ? path : '/$path',
    ).toString();
  }

  /// Helper method to safely convert numeric values to integers
  int? safeToInt(dynamic value) {
    if (value == null) return null;
    if (value is int) return value;
    if (value is double) return value.round();
    if (value is String) {
      try {
        return double.parse(value).round();
      } catch (e) {
        return null;
      }
    }
    return null;
  }

  /// Helper method to convert numeric values to integers with a default
  int safeToIntWithDefault(dynamic value, int defaultValue) {
    return safeToInt(value) ?? defaultValue;
  }

  /// Helper method to safely convert values to doubles
  double? safeToDouble(dynamic value) {
    if (value == null) return null;
    if (value is double) return value;
    if (value is int) return value.toDouble();
    if (value is String) {
      try {
        return double.parse(value);
      } catch (e) {
        return null;
      }
    }
    return null;
  }
}
